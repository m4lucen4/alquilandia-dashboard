import { supabase } from "@/config/supabase";
import type { CreateInvoiceData, Invoice } from "@/types/invoices";
import type { Json } from "@/types/supabase";
import { generateInvoicePDF } from "./pdfService";

/**
 * Gets all invoices with business information
 *
 * @param businessId - Optional business ID to filter by
 * @param budgetReference - Optional budget reference to filter by
 * @returns Array of invoices with business details
 * @throws Error if fetch fails
 */
export const getAllInvoices = async (
  businessId?: string,
  budgetReference?: string,
): Promise<Invoice[]> => {
  let query = supabase.from("invoices").select(
    `
      *,
      business:business_id (
        id,
        name
      )
    `,
  );

  // Apply filters if provided
  if (businessId) {
    query = query.eq("business_id", businessId);
  }

  if (budgetReference) {
    query = query.eq("budget_reference", budgetReference);
  }

  const { data, error } = await query.order("created_at", { ascending: false });

  if (error) {
    console.error("Error fetching invoices:", error);
    throw new Error(
      error.message ||
        "No se pudieron cargar las facturas. Por favor, inténtelo de nuevo.",
    );
  }

  return (data || []) as Invoice[];
};

/**
 * Gets invoice by budget reference
 *
 * @param budgetReference - Budget reference number
 * @returns Invoice if found, null otherwise
 * @throws Error if fetch fails
 */
export const getInvoiceByBudgetReference = async (
  budgetReference: number,
): Promise<Invoice | null> => {
  const { data, error } = await supabase
    .from("invoices")
    .select(
      `
      *,
      business:business_id (
        id,
        name,
        nif,
        address,
        locality,
        province,
        phone,
        postal_code
      ),
      invoices_type:invoices_type_id (
        id,
        invoices,
        percentage
      ),
      taxes_type:taxes_type_id (
        id,
        name,
        tax
      )
    `,
    )
    .eq("budget_reference", budgetReference)
    .single();

  if (error) {
    if (error.code === "PGRST116") {
      // No rows returned
      return null;
    }
    console.error("Error fetching invoice by budget reference:", error);
    throw new Error(
      error.message ||
        "No se pudo cargar la factura. Por favor, inténtelo de nuevo.",
    );
  }

  return data as Invoice;
};

/**
 * Creates a new invoice in Supabase with PDF generation
 * Invoice number is auto-generated by the database trigger
 *
 * @param invoiceData - Data for the new invoice
 * @returns The created invoice with PDF URL
 * @throws Error if creation fails
 */
export const createInvoice = async (
  invoiceData: CreateInvoiceData,
): Promise<Invoice> => {
  const insertData = {
    business_id: invoiceData.business_id,
    invoices_type_id: invoiceData.invoices_type_id,
    taxes_type_id: invoiceData.taxes_type_id,
    budget_reference: invoiceData.budget_reference,
    budgetlines: invoiceData.budgetlines as unknown as Json,
    price: invoiceData.price as unknown as Json,
  };

  // Step 1: Create the invoice
  // Note: Using 'as any' to bypass Supabase type inference issue
  // The insertData object is correctly typed, but Supabase's generic type isn't propagating
  const { data: createdInvoice, error: createError } = (await supabase
    .from("invoices")
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .insert(insertData as any)
    .select()
    .single()) as { data: Invoice | null; error: { message?: string } | null };

  if (createError || !createdInvoice) {
    console.error("Error creating invoice:", createError);
    throw new Error(
      createError?.message ||
        "No se pudo crear la factura. Por favor, inténtelo de nuevo.",
    );
  }

  try {
    // Get the complete invoice with all relations
    const { data: fullInvoice, error: fetchError } = await supabase
      .from("invoices")
      .select(
        `
        *,
        business:business_id (
          id,
          name,
          nif,
          address,
          locality,
          province,
          phone,
          postal_code
        ),
        invoices_type:invoices_type_id (
          id,
          invoices,
          percentage
        ),
        taxes_type:taxes_type_id (
          id,
          name,
          tax
        )
      `,
      )
      .eq("id", createdInvoice.id as string)
      .single();

    if (fetchError || !fullInvoice) {
      console.error("Error fetching full invoice:", fetchError);
      throw new Error("No se pudo obtener los datos completos de la factura.");
    }

    // Generate PDF
    const pdfBlob = await generateInvoicePDF(fullInvoice as Invoice);

    // Upload PDF to Supabase Storage
    const fileName = `invoice_${createdInvoice.id}.pdf`;
    const { error: uploadError } = await supabase.storage
      .from("invoices-pdf")
      .upload(fileName, pdfBlob, {
        contentType: "application/pdf",
        upsert: true,
      });

    if (uploadError) {
      console.error("Error uploading PDF:", uploadError);
      throw new Error(
        `No se pudo subir el PDF: ${uploadError.message || "Error desconocido"}`,
      );
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from("invoices-pdf")
      .getPublicUrl(fileName);

    const pdfUrl = urlData.publicUrl;

    // Update invoice with PDF URL
    // Note: Using type assertion to bypass Supabase type inference issue
    // The update object is correctly typed, but Supabase's generic type isn't propagating
    const { data: updatedInvoice, error: updateError } = (await supabase
      .from("invoices")
      // @ts-expect-error - Supabase type inference bug: incorrectly infers update param as 'never'
      .update({ pdf_url: pdfUrl })
      .eq("id", createdInvoice.id as string)
      .select(
        `
        *,
        business:business_id (
          id,
          name,
          nif,
          address,
          locality,
          province,
          phone,
          postal_code
        ),
        invoices_type:invoices_type_id (
          id,
          invoices,
          percentage
        ),
        taxes_type:taxes_type_id (
          id,
          name,
          tax
        )
      `,
      )
      .single()) as {
      data: Invoice | null;
      error: { message?: string } | null;
    };

    if (updateError || !updatedInvoice) {
      console.error("Error updating invoice with PDF URL:", updateError);
      // Even if update fails, we still return the invoice
      return { ...(fullInvoice as Invoice), pdf_url: pdfUrl } as Invoice;
    }

    return updatedInvoice as Invoice;
  } catch (error) {
    console.error(
      "Error in invoice creation process:",
      error instanceof Error ? error.message : error,
    );
    // If PDF generation/upload fails, we still have the invoice created
    // Return it without PDF URL
    return createdInvoice as Invoice;
  }
};
